# Unity Dev Agent - 规格说明书

> **文档编号**: UDA-SPEC-001  
> **版本**: v1.0  
> **状态**: 草案  
> **最后更新**: 2026-02-26

---

## 1. 引言

### 1.1 目的

本文档详细定义 Unity Dev Agent 的功能规格、行为规格和验收标准，作为开发、测试和验收的依据。

### 1.2 适用范围

适用于 Agent 的全生命周期：需求理解、代码生成、编译验证、运行时验证。

### 1.3 参考文档

- MCP Protocol Specification
- Unity MCP Plugin API Reference
- ReAct Pattern Whitepaper

---

## 2. 功能规格 (Functional Specification)

### 2.1 模块概览

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Unity Dev Agent                              │
├─────────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │
│  │ Spec Module │  │ Code Module │  │ Build Module│  │  Validation │ │
│  │   (规格)    │  │   (代码)    │  │   (编译)    │  │   (验证)    │ │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 2.2 Spec Module (规格模块)

#### 2.2.1 需求收集 (Requirement Gathering)

**功能ID**: SPEC-001  
**描述**: 与用户进行多轮对话，收集完整的需求信息  
**输入**: 用户的初始自然语言描述  
**输出**: 结构化需求文档

**对话策略**:
```yaml
clarification_strategy:
  # 当用户描述不完整时，Agent应主动询问
  triggers:
    - missing_parameters: "缺少必要的参数信息"
    - ambiguous_description: "描述存在歧义"
    - unclear_scope: "范围不明确"
    
  question_types:
    - functional: "这个工具需要支持哪些功能？"
    - constraint: "有什么限制条件吗？比如性能要求"
    - preference: "UI风格有偏好吗？比如现代风格或经典风格"
    - context: "这个工具是给谁用的？程序员还是美术？"
```

**示例对话**:
```
用户: 我要一个道路生成工具

Agent: 为了更好地实现这个工具，我需要了解几个细节：
1. 道路的形状是直线、曲线都可以支持吗？
2. 需要支持哪些可调节参数？（如宽度、长度、材质等）
3. 这个工具是给关卡设计师用还是程序员用？
4. 生成的道路是运行时生成还是Editor中预先生成？
```

#### 2.2.2 技术方案生成 (Technical Spec Generation)

**功能ID**: SPEC-002  
**描述**: 基于收集的需求，生成详细的技术规格文档  
**输入**: 结构化需求文档  
**输出**: Technical Spec Document (Markdown格式)

**Spec文档必须包含**:
```markdown
1. 功能规格 (Functional Spec)
   - 输入参数定义（名称、类型、范围、默认值）
   - 输出结果定义
   - 核心功能点
   
2. 技术规格 (Technical Spec)
   - 类设计（类名、方法签名、属性）
   - 算法逻辑（伪代码或流程图）
   - 依赖项清单
   
3. UI规格 (UI Spec)
   - 窗口布局描述
   - 控件清单（按钮、输入框等）
   - 交互流程
   
4. 验证标准 (Validation Criteria)
   - 功能验证点
   - 日志检查规则
   - 视觉验证描述
```

#### 2.2.3 用户确认流程 (User Confirmation)

**功能ID**: SPEC-003  
**描述**: 向用户展示生成的Spec，等待确认或修改  
**交互方式**:
- 显示完整的Spec文档
- 用户可以提出修改意见
- Agent根据反馈修订Spec
- 最多3轮修订循环

**确认标准**:
- 用户明确回复"确认"或"开始开发"
- 用户不做修改直接继续

---

### 2.3 Code Module (代码模块)

#### 2.3.1 代码生成 (Code Generation)

**功能ID**: CODE-001  
**描述**: 基于确认后的Spec生成C#代码  
**输入**: Technical Spec Document  
**输出**: C#脚本文件内容

**生成策略**:
```yaml
strategy:
  template_based: true      # 使用模板确保代码风格一致
  incremental: false        # 首次全量生成
  namespace: "AutoGenerated.Tools"
  folder_structure:
    root: "Assets/AutoGenerated/"
    subfolders:
      - "Editor/"           # Editor工具
      - "Runtime/"          # Runtime组件
      - "Tests/"            # 测试脚本
```

**代码模板示例**:
```csharp
// Editor工具模板
using UnityEngine;
using UnityEditor;

namespace AutoGenerated.Tools.Editor
{
    public class {ToolName}Window : EditorWindow
    {
        [MenuItem("Tools/{ToolName}")]
        public static void ShowWindow()
        {
            GetWindow<{ToolName}Window>("{ToolName}");
        }
        
        private void OnGUI()
        {
            // UI generated based on Spec
        }
    }
}
```

#### 2.3.2 代码修复 (Code Fixing)

**功能ID**: CODE-002  
**描述**: 根据编译错误修复代码  
**输入**: 原始代码 + 编译错误信息  
**输出**: 修复后的代码

**修复策略** (待决策者确认):

**策略A: 增量修复**:
```csharp
// 仅修改出错的部分
// 需要精确定位错误位置
// 保留其他正确代码
```

**策略B: 全量重新生成**:
```csharp
// 基于错误信息重新生成完整代码
// 可能改变代码结构
// 成本高但一致性好
```

**错误分类处理**:
| 错误类型 | 处理策略 |
|----------|----------|
| Syntax Error | 直接修复语法 |
| Type Not Found | 检查命名空间/引用 |
| Missing Method | 补全方法或修改调用 |
| Reference Error | 添加using或修改类型 |

---

### 2.4 Build Module (编译模块)

#### 2.4.1 编译检测 (Compilation Check)

**功能ID**: BUILD-001  
**描述**: 检测代码是否能通过Unity编译  
**输入**: C#脚本文件  
**输出**: 编译结果（成功/失败 + 错误列表）

**实现方式**:
```csharp
// 使用Unity MCP的脚本更新工具
// 触发AssetDatabase.Refresh()
// 监听EditorApplication.isCompiling
// 检查EditorUtility.scriptCompilationFailed
```

**编译状态检测**:
```yaml
compilation_states:
  - idle: "无编译进行"
  - compiling: "正在编译，需等待"
  - succeeded: "编译成功"
  - failed: "编译失败，获取错误信息"
```

#### 2.4.2 Domain Reload 处理

**功能ID**: BUILD-002  
**描述**: 处理编译时的Domain Reload，保持Agent状态  
**挑战**: Unity编译会触发Domain Reload，导致所有对象重置

**解决方案**:
```csharp
[InitializeOnLoad]
public class AgentStatePersistence
{
    // 使用EditorPrefs或文件保存状态
    // 编译完成后自动恢复
    // 重新建立MCP连接
}
```

**状态保存内容**:
- 当前迭代次数
- 当前代码版本
- 用户原始需求
- Spec文档

---

### 2.5 Validation Module (验证模块)

#### 2.5.1 运行时执行 (Runtime Execution)

**功能ID**: VAL-001  
**描述**: 在Unity中执行生成的工具并验证功能  
**步骤**:
1. 保存当前场景
2. 进入PlayMode
3. 执行工具的核心功能
4. 收集日志和截图
5. 退出PlayMode
6. 恢复场景

**安全机制**:
```yaml
safety_checks:
  - scene_backup: "执行前自动保存场景"
  - timeout: "PlayMode最长运行30秒"
  - error_threshold: "Error日志超过3个立即终止"
  - infinite_loop_detection: "检测无限循环并终止"
```

#### 2.5.2 截图验证 (Screenshot Validation)

**功能ID**: VAL-002  
**描述**: 捕获截图并使用多模态AI验证  
**截图类型**:
- Scene View: 验证3D对象是否正确显示
- Game View: 验证游戏运行时效果
- Editor Window: 验证UI界面

**验证方式** (待决策者确认):

**方式A: 多模态LLM分析**:
```
将截图 + 预期描述 发送到Claude Vision API
返回: 匹配度评分 + 详细分析
```

**方式B: 结构化比对**:
```
预定义验证点（如"窗口中应有3个按钮"）
使用图像处理库检测UI元素
```

#### 2.5.3 日志分析 (Log Analysis)

**功能ID**: VAL-003  
**描述**: 分析Unity Console日志  
**日志级别检查**:
```yaml
log_validation:
  error:
    max_count: 0        # 不允许Error
    patterns_to_check:
      - "NullReferenceException"
      - "IndexOutOfRangeException"
      - "MissingReferenceException"
  
  warning:
    max_count: 5        # 最多5个Warning
    patterns_to_ignore: # 可忽略的Warning
      - "Obsolete"
  
  required_logs:        # 必须出现的日志
    - "[Tool] Initialization complete"
    - "[Tool] Execution finished"
```

---

### 2.6 ReAct 循环引擎

#### 2.6.1 观察 (Observe)

**功能ID**: REACT-001  
**描述**: 收集当前环境状态  
**观察内容**:
```yaml
observation_data:
  compilation_status: "编译成功/失败 + 错误详情"
  runtime_logs: "PlayMode期间的日志"
  screenshots: "Scene/Game/Editor窗口截图"
  tool_state: "工具执行后的场景状态"
```

#### 2.6.2 思考 (Think)

**功能ID**: REACT-002  
**描述**: 基于观察结果进行分析  
**思考维度**:
- 当前进度评估（完成百分比）
- 问题诊断（为什么失败）
- 下一步行动选择

**思考输出格式**:
```json
{
  "current_status": "compiling",
  "progress": "30%",
  "analysis": "代码存在语法错误，需要修复",
  "next_action": "fix_code",
  "confidence": 0.85
}
```

#### 2.6.3 行动 (Act)

**功能ID**: REACT-003  
**描述**: 执行具体操作  
**行动类型**:
| 行动 | 工具调用 | 说明 |
|------|----------|------|
| generate_code | script-update-or-create | 生成新代码 |
| fix_code | script-update-or-create | 修复代码 |
| compile | asset-refresh | 触发编译 |
| run_playmode | editor-set-state | 进入PlayMode |
| capture_screenshot | screenshot-* | 截图 |
| analyze_logs | console-get-logs | 获取日志 |

#### 2.6.4 反思 (Reflect)

**功能ID**: REACT-004  
**描述**: 评估行动结果，更新策略  
**反思内容**:
- 本次行动是否有效
- 是否需要调整策略
- 是否达到终止条件

**终止条件**:
```yaml
termination_conditions:
  success:
    - 编译通过 AND 运行时验证通过
    - 用户主动确认完成
  
  failure:
    - 达到最大迭代次数
    - 连续3次同一错误
    - 用户要求终止
  
  partial:
    - 编译通过但运行时部分失败
    - 需要用户决策是否继续
```

---

## 3. 非功能规格 (Non-Functional Specification)

### 3.1 性能规格

| 指标 | 要求 | 说明 |
|------|------|------|
| 单次代码生成时间 | < 30秒 | 从接收Spec到输出代码 |
| 编译检测超时 | 60秒 | 超过则视为失败 |
| PlayMode执行超时 | 30秒 | 防止无限循环 |
| 单次迭代总时间 | < 2分钟 | 完整ReAct循环 |
| 最大迭代次数 | 10次 | 防止无限循环 |
| 内存占用 | < 500MB | Agent进程 |

### 3.2 可靠性规格

| 指标 | 要求 | 说明 |
|------|------|------|
| Domain Reload恢复率 | 100% | 编译后必须能恢复状态 |
| MCP连接稳定性 | 99% | 连接成功率 |
| 状态持久化 | 100% | 关键状态不丢失 |
| 异常处理覆盖率 | 100% | 所有异常都要捕获处理 |

### 3.3 可维护性规格

```yaml
maintainability:
  logging:
    level: "DEBUG"           # 详细日志便于调试
    format: "[Agent][{Module}] {Message}"
    retention: "7 days"
  
  configuration:
    file: "agent-config.yaml"
    hot_reload: true         # 配置修改无需重启
  
  extension:
    plugin_system: true      # 支持自定义验证规则
```

---

## 4. 接口规格 (Interface Specification)

### 4.1 MCP 工具调用接口

```csharp
// 统一的工具调用接口
public interface IMcpToolInvoker
{
    Task<ToolResult> InvokeAsync(string toolName, object parameters);
    Task<bool> WaitForCompletion(string requestId, TimeSpan timeout);
}

// 工具调用结果
public class ToolResult
{
    public bool Success { get; set; }
    public string RequestId { get; set; }
    public object Data { get; set; }
    public string Error { get; set; }
    public ToolStatus Status { get; set; }
}
```

### 4.2 Agent 对外接口

```csharp
// 用户层接口
public interface IUnityDevAgent
{
    // 开始开发任务
    Task<DevelopmentResult> DevelopAsync(
        string requirement, 
        CancellationToken cancellationToken = default);
    
    // 获取当前状态
    AgentStatus GetStatus();
    
    // 用户干预
    Task ProvideFeedback(string feedback);
    
    // 终止任务
    void Terminate();
}
```

---

## 5. 验收标准 (Acceptance Criteria)

### 5.1 功能验收

| ID | 验收项 | 验收标准 | 优先级 |
|----|--------|----------|--------|
| AC-01 | 需求收集 | Agent能主动询问并收集完整需求 | P0 |
| AC-02 | Spec生成 | 生成符合模板的Technical Spec | P0 |
| AC-03 | 代码生成 | 根据Spec生成可编译的C#代码 | P0 |
| AC-04 | 编译修复 | 编译失败后能自动修复直至通过 | P0 |
| AC-05 | 运行时验证 | 能进入PlayMode并执行功能验证 | P1 |
| AC-06 | 截图分析 | 能验证UI是否正确渲染 | P1 |
| AC-07 | 日志检查 | 能检测Error/Warning日志 | P1 |
| AC-08 | 完整闭环 | 从需求到可运行工具的端到端流程 | P0 |

### 5.2 性能验收

| ID | 验收项 | 验收标准 |
|----|--------|----------|
| AC-P01 | 开发时间 | 简单工具（< 200行代码）< 30分钟 |
| AC-P02 | 迭代效率 | 编译修复平均 < 3次迭代 |
| AC-P03 | 稳定性 | 连续运行10次任务不崩溃 |

---

## 6. 边界情况处理 (Edge Cases)

### 6.1 编译相关

| 场景 | 处理策略 |
|------|----------|
| 编译卡住 | 超时60秒后强制终止，提示用户 |
| 循环依赖 | 检测并提示用户手动解决 |
| 缺少引用 | 自动检测并建议添加using或Package |

### 6.2 运行时相关

| 场景 | 处理策略 |
|------|----------|
| PlayMode崩溃 | 捕获异常，记录日志，尝试恢复场景 |
| 无限循环 | 30秒超时强制退出 |
| 场景污染 | 执行前自动备份，失败后可恢复 |

### 6.3 Agent相关

| 场景 | 处理策略 |
|------|----------|
| 上下文溢出 | 自动压缩历史，保留关键信息 |
| 循环无法收敛 | 达到最大迭代次数后转人工 |
| MCP连接断开 | 自动重连，最多3次 |

---

## 7. 待确认规格 (Pending Specifications)

以下规格需要决策者确认：

### 7.1 验证标准定义方式

**选项A**: 自然语言描述
```yaml
validation:
  screenshot: "应该显示一个带有红色按钮的窗口"
```

**选项B**: 结构化规则
```yaml
validation:
  ui_elements:
    - type: button
      color: "#FF0000"
      position: "top-left"
      count: 1
```

**需要您决策**: _____________

### 7.2 用户干预时机

**选项A**: 仅在Spec阶段和最终结果确认
**选项B**: 每轮迭代后都向用户汇报并等待确认
**选项C**: 仅在发生异常或无法自动解决时

**需要您决策**: _____________

### 7.3 代码质量要求

**选项A**: 可用即可（快速迭代）
**选项B**: 必须符合C#代码规范（XML注释、命名规范等）
**选项C**: 包含基础单元测试

**需要您决策**: _____________

---

## 8. 附录

### 8.1 术语表

| 术语 | 定义 |
|------|------|
| ReAct | Reasoning + Acting，一种AI Agent设计模式 |
| Spec | Specification，技术规格文档 |
| MCP | Model Context Protocol，AI与Unity通信协议 |
| Domain Reload | Unity编译后重置应用域的操作 |

### 8.2 参考示例

- 示例1: 简单Editor工具开发完整流程
- 示例2: Gameplay系统开发完整流程
- 示例3: 复杂UI界面开发完整流程

---

**文档审批**:

| 角色 | 姓名 | 日期 | 意见 |
|------|------|------|------|
| 作者 | | | |
| 审核 | | | |
| 批准 | | | |
