/*
┌──────────────────────────────────────────────────────────────────┐
│  Unity Dev Agent - Road Generation Domain Prompt                 │
│  Repository: GitHub (https://github.com/IvanMurzak/Unity-MCP)   │
│  Part of Unity Dev Agent (UDA) infrastructure                    │
└──────────────────────────────────────────────────────────────────┘
*/

#nullable enable
using System.ComponentModel;
using com.IvanMurzak.McpPlugin;
using com.IvanMurzak.McpPlugin.Common.Model;

namespace com.IvanMurzak.Unity.MCP.Editor.API
{
    public partial class Prompt_DevAgent
    {
        [McpPluginPrompt(Name = "road-generation-tool", Role = Role.User)]
        [Description("Domain knowledge prompt for building a Road Generation Tool in Unity. " +
            "Provides technical guidance on procedural mesh generation, Bézier curves, " +
            "EditorWindow UI, and SceneView Handles. Use together with 'react-dev-agent' prompt.")]
        public string RoadGenerationTool()
        {
            return @"# Road Generation Tool — Domain Knowledge

## Task Description
Build a **Road Generation Tool** for the Unity Editor that allows users to create
procedural road meshes along a path defined by control points.

## Recommended Architecture

### File Manifest
| File | Class | Responsibility |
|------|-------|----------------|
| `Assets/AutoGenerated/RoadGenerator/RoadData.cs` | `RoadData` | ScriptableObject storing road configuration (width, resolution, control points) |
| `Assets/AutoGenerated/RoadGenerator/BezierUtils.cs` | `BezierUtils` | Static utility class for Bézier curve math (quadratic & cubic) |
| `Assets/AutoGenerated/RoadGenerator/RoadMeshBuilder.cs` | `RoadMeshBuilder` | Core mesh generation: vertices, triangles, UVs, normals from a path |
| `Assets/AutoGenerated/RoadGenerator/RoadGeneratorWindow.cs` | `RoadGeneratorWindow` | EditorWindow with UI controls for road parameters |
| `Assets/AutoGenerated/RoadGenerator/RoadComponent.cs` | `RoadComponent` | MonoBehaviour attached to the road GameObject, holds mesh and data reference |

### Key Unity APIs
- `Mesh` — `vertices`, `triangles`, `uv`, `normals`, `RecalculateNormals()`, `RecalculateBounds()`
- `MeshFilter` — holds the generated mesh
- `MeshRenderer` — renders with a material
- `EditorWindow` — `OnGUI()`, `GUILayout`, `EditorGUILayout`
- `Handles` — `DrawLine`, `FreeMoveHandle`, `PositionHandle` (for SceneView interaction)
- `SceneView.duringSceneGui` — register custom SceneView drawing
- `AssetDatabase.CreateAsset()` — save ScriptableObject
- `Undo.RecordObject()` — support undo operations

### Bézier Curve Mathematics

**Quadratic Bézier** (3 control points):
```
B(t) = (1-t)²·P0 + 2(1-t)t·P1 + t²·P2,  t ∈ [0,1]
```

**Cubic Bézier** (4 control points):
```
B(t) = (1-t)³·P0 + 3(1-t)²t·P1 + 3(1-t)t²·P2 + t³·P3,  t ∈ [0,1]
```

For a road, sample the curve at `resolution` intervals, then at each sample point:
1. Calculate the tangent: `B'(t)` (derivative)
2. Calculate the normal: `cross(tangent, Vector3.up).normalized`
3. Generate two vertices: `point ± normal * (width / 2)`

### Mesh Generation Algorithm (Pseudocode)
```
function GenerateRoadMesh(controlPoints, width, resolution):
    vertices = []
    triangles = []
    uvs = []
    
    pathPoints = SampleBezierPath(controlPoints, resolution)
    totalLength = CalculatePathLength(pathPoints)
    accumulatedLength = 0
    
    for i = 0 to pathPoints.length - 1:
        point = pathPoints[i]
        tangent = (pathPoints[min(i+1, len-1)] - pathPoints[max(i-1, 0)]).normalized
        normal = cross(tangent, Vector3.up).normalized
        
        leftVertex = point - normal * width / 2
        rightVertex = point + normal * width / 2
        
        vertices.add(leftVertex)
        vertices.add(rightVertex)
        
        // UV: x = 0 or 1 (left/right), y = accumulated distance / total
        if i > 0:
            accumulatedLength += distance(pathPoints[i], pathPoints[i-1])
        uvProgress = accumulatedLength / totalLength
        uvs.add(Vector2(0, uvProgress))
        uvs.add(Vector2(1, uvProgress))
        
        // Triangles (two per quad, between current and previous pair)
        if i > 0:
            baseIndex = (i - 1) * 2
            triangles.add(baseIndex, baseIndex + 2, baseIndex + 1)
            triangles.add(baseIndex + 1, baseIndex + 2, baseIndex + 3)
    
    mesh = new Mesh()
    mesh.vertices = vertices
    mesh.triangles = triangles
    mesh.uv = uvs
    mesh.RecalculateNormals()
    mesh.RecalculateBounds()
    return mesh
```

### EditorWindow UI Layout
```
┌─── Road Generator ──────────────────────┐
│                                          │
│  Road Width:    [====|=====] 4.0         │
│  Resolution:    [====|=====] 20          │
│  Curve Type:    [Quadratic ▼]            │
│                                          │
│  Control Points: 3                       │
│  ┌──────────────────────────────────┐    │
│  │ P0: (0, 0, 0)     [Select]      │    │
│  │ P1: (5, 0, 10)    [Select]      │    │
│  │ P2: (10, 0, 0)    [Select]      │    │
│  └──────────────────────────────────┘    │
│  [+ Add Point]  [- Remove Last]          │
│                                          │
│  Material:      [Default-Material ◉]     │
│                                          │
│  [Generate Road]  [Clear Road]           │
│                                          │
└──────────────────────────────────────────┘
```

### Validation Criteria

**Compilation**: 0 Errors

**Visual (SceneView screenshot)**:
- A visible mesh strip (the road) should appear in the scene
- The road should follow a curved or straight path
- Control point gizmos should be visible (if Handles are implemented)

**Visual (GameView screenshot)**:
- The road mesh should be visible from the game camera
- Material should be applied (not pink/magenta = missing shader)

**Logs**:
- Expected: `""[RoadGenerator] Road mesh generated with X vertices""` (where X > 0)
- Expected: `""[RoadGenerator] EditorWindow initialized""` (when window opens)
- Forbidden: `NullReferenceException`, `IndexOutOfRangeException`

### Common Pitfalls & Solutions
1. **Pink material**: Use `new Material(Shader.Find(""Standard""))` as default
2. **Invisible mesh**: Ensure normals are calculated and MeshRenderer has material
3. **Flat road on slopes**: For V1, assume flat terrain (Y=0). Note as limitation.
4. **Undo not working**: Wrap modifications in `Undo.RecordObject()`
5. **SceneView handles not showing**: Must subscribe to `SceneView.duringSceneGui`
6. **Editor-only code in runtime script**: Use `#if UNITY_EDITOR` guards for Handles code";
        }
    }
}